import {
  AssetType,
  BlinnPhongMaterial,
  BoxColliderShape,
  Camera,
  Engine,
  Entity,
  Keys,
  MeshRenderer,
  PrimitiveMesh,
  Rect,
  Script,
  Sprite,
  SpriteRenderer,
  StaticCollider,
  Texture2D,
  UnlitMaterial,
  Vector2,
  Vector3,
  WebGLEngine,
} from 'oasis-engine';
import * as TWEEN from '@tweenjs/tween.js';
import { LitePhysics } from "@oasis-engine/physics-lite";

let gameResArray: Texture2D[];
let engine: WebGLEngine;
const GameEvent = {
  fly: 'fly',
  stateChange: 'stateChange',
  showGui: 'showGui',
  checkHitGui: 'checkHitGui',
  checkHit: 'checkHit',
  gameOver: 'gameOver',
  addScore: 'addScore',
  reStartGame: 'reStartGame',
};
enum EnumGameState {
  Idel = 0,
  Start = 1,
  End = 2,
}
enum EnumBirdState {
  Alive = 0,
  Dead = 1,
}

// 与地面碰撞检测的 Y 坐标
const groundY = -3.1;

class ScriptPipe extends Script {
  /** When there is no pipe in the pool, use this instance to clone. */
  private _originPipe: Entity;
  /** All current pipes. */
  private _nowPipeArr: Array<Entity> = [];
  /** Pool for reuse. */
  private _pipePool: Array<Entity> = [];
  /** Timestamp of the start of the game. */
  private _curStartTimeStamp: number;
  /**  Hide when the x coordinate of the pipe is less than -4.6. */
  private _pipeHideX: number = 4.6;
  /**  Vertical distance of pipe. */
  private _pipeVerticalDis: number = 10.8;
  /**  Horizontal distance of pipe. */
  private _pipeHorizontalDis: number = 4;
  /**  Random location range generated by pipes. */
  private _pipeRandomPosY: number = 3.5;
  /**  Water pipe debut time(ms). */
  private _pipeDebutTime: number = 3000;
  /**  Horizontal movement speed. */
  private _pipeHorizontalV: number = 0.003;

  onAwake() {
    // 初始化管道
    const pipe = (this._originPipe = new Entity(engine));
    const node1 = pipe.createChild('node1');
    const node2 = pipe.createChild('node2');
    const verticalDis = this._pipeVerticalDis;
    node1.transform.setPosition(0, -verticalDis / 2, 0);
    node2.transform.setPosition(0, verticalDis / 2, 0);
    node2.transform.setScale(1, -1, 1);
    node1.addComponent(SpriteRenderer).sprite = new Sprite(
      engine,
      gameResArray[1]
    );
    node2.addComponent(SpriteRenderer).sprite = new Sprite(
      engine,
      gameResArray[1]
    );
    this._pipePool.push(pipe);

    // Control the performance of the pipe according to the change of the game state.
    // 监听游戏事件来控制管道
    engine.on(GameEvent.stateChange, (gameState: EnumGameState) => {
      switch (gameState) {
        case EnumGameState.Idel:
          this.enabled = false;
          this._destroyPipe();
          break;
        case EnumGameState.Start:
          this.enabled = true;
          this._curStartTimeStamp = engine.time.nowTime;
          break;
        case EnumGameState.End:
          this.enabled = false;
          break;
      }
    });

    // When checkHit is monitored, check the collision between the pipe and the bird.
    // 响应管道的碰撞检测，检测管道和鸟是否相撞
    engine.on(GameEvent.checkHit, (birdY: number) => {
      var len = this._nowPipeArr.length;
      for (var i = 0; i < len; i++) {
        var pipePos = this._nowPipeArr[i].transform.position;
        if (Math.abs(pipePos.x) < 0.9) {
          // 当管道移动到鸟的位置时，判断每个管道的 y 和鸟的 y 坐标距离小于一个值即撞到了（都不需要用到物理碰撞）
          if (Math.abs(pipePos.y - birdY) > 1.2) {
            engine.dispatch(GameEvent.gameOver);
          }
          break;
        }
      }
    });
  }

  /**
   * Three things will be done here every frame：
   *    1.Adjust the generation of the pipe.
   *    2.Adjust the position of the pipe.
   *    3.Judge whether to get a point.
   * @param deltaTime - The deltaTime when the script update
   */
  onUpdate(deltaTime: number) {
    const debutTime = this._pipeDebutTime;
    // The water pipe will be displayed after the start of the game pipeDebutTime.

    if (engine.time.nowTime - this._curStartTimeStamp >= debutTime) {
      let bAddScore = false;
      // After deltaTime, the distance the pipe has moved.
      // 按固定间隔时间移动管道
      const changeVal = deltaTime * this._pipeHorizontalV;
      const pipeLen = this._nowPipeArr.length;
      const {
        _pipeHorizontalDis: horizontalDis,
        _pipeRandomPosY: randomPosY,
        _pipeHideX: hideX,
      } = this;
      // Adjust the position of all pipes.
      if (pipeLen > 0) {
        for (let i = pipeLen - 1; i >= 0; i--) {
          const pipe = this._nowPipeArr[i];
          const pipeTrans = pipe.transform;
          const pipePos = pipeTrans.position;
          if (pipePos.x < -hideX) {
            // The invisible pipe can be destroyed.
            this._destroyPipe(i);
          } else {
            if (!bAddScore && pipePos.x > -1 && pipePos.x - changeVal <= -1) {
              // Get a point.
              engine.dispatch(GameEvent.addScore);
              bAddScore = true;
            }
            pipeTrans.setPosition(pipePos.x - changeVal, pipePos.y, pipePos.z);
          }
          // Judge whether the pipe needs to be regenerated according to the X coordinate.
          if (i == pipeLen - 1 && pipePos.x <= hideX - horizontalDis) {
            this._createPipe(
              hideX,
              randomPosY * Math.random() - randomPosY / 2 + 0.8,
              0
            );
          }
        }
      } else {
        // Need to regenerate a pipe.
        this._createPipe(
          hideX,
          randomPosY * Math.random() - randomPosY / 2 + 0.8,
          0
        );
      }
    }
  }

  private _createPipe(posX: number, posY: number, posZ: number) {
    const pipePool = this._pipePool;
    const pipe =
      pipePool.length > 0 ? pipePool.pop() : this._originPipe.clone();
    pipe.transform.setPosition(posX, posY, posZ);
    this.entity.addChild(pipe);
    this._nowPipeArr.push(pipe);
  }

  /**
   * It’s not really destroyed, we just put it in the pool.
   * @param pipeIndex - If pipeIndex is less than 0, we recycle all pipes
   */
  private _destroyPipe(pipeIndex: number = -1) {
    const { entity, _pipePool, _nowPipeArr } = this;
    const removePipe = (pipe: Entity) => {
      entity.removeChild(pipe);
      _pipePool.push(pipe);
    };
    if (pipeIndex >= 0) {
      removePipe(_nowPipeArr[pipeIndex]);
      _nowPipeArr.splice(pipeIndex, 1);
    } else {
      for (let index = _nowPipeArr.length - 1; index >= 0; index--) {
        removePipe(_nowPipeArr[index]);
      }
      _nowPipeArr.length = 0;
    }
  }
}

class ScriptGround extends Script {
  /** Swap two pieces of ground to achieve constant movement. */
  private _groundMaterial: UnlitMaterial; // 地面材质
  /** Horizontal movement speed. */
  private _groundHorizontalV: number = 0.0082; // 水平移动速度

  onAwake() {
    this._groundMaterial = <UnlitMaterial>(
      this.entity.getComponent(MeshRenderer).getMaterial()
    );
    // Control the performance of the ground according to the change of the game state.
    // 根据游戏状态响应地面的渲染
    engine.on(GameEvent.stateChange, (gameState: EnumGameState) => {
      switch (gameState) {
        case EnumGameState.Idel:
        case EnumGameState.Start:
          this.enabled = true;
          break;
        case EnumGameState.End:
          this.enabled = false;
          break;
        default:
          break;
      }
    });

    // When checkHit is monitored, check the collision between the ground and the bird.
    engine.on(GameEvent.checkHit, (birdY) => {
      birdY < groundY && engine.dispatch(GameEvent.gameOver);
    });
  }

  onUpdate(deltaTime: number) {
    // After deltaTime, the distance the ground has moved.
    // 按固定间隔时间移动地面
    this._groundMaterial.tilingOffset.z += deltaTime * this._groundHorizontalV;
  }
}

class ScriptBird extends Script {
  /** Offsets of sprite sheet animation. */
  private _regions: Vector2[] = [
    new Vector2(0, 0),
    new Vector2(1 / 3, 0),
    new Vector2(2 / 3, 0),
  ];
  /** Reciprocal Of SliceWidth. */
  private _reciprocalSliceWidth: number = 1 / 3;
  /** Reciprocal Of SliceHeight. */
  private _reciprocalSliceHeight: number = 1;
  /** Frame interval time, the unit of time is ms. */
  private _frameInterval = 150;
  /** Total frames. */
  private _totalFrames = 3;
  /** Maximum downward speed */
  private _maxDropV = -8;
  /** Acceleration of gravity */
  private _gravity = -35; // 重力系数
  /** Initial upward speed given during fly */
  private _startFlyV = 10;

  private _cumulativeTime: number = 0;
  private _birdState = EnumBirdState.Alive;

  private _sprite: Sprite;
  private _curFrameIndex: number;
  private _startY: number;
  private _flyStartTime: number;
  private _gameState: EnumGameState;
  private _yoyoTween;
  private _dropTween;

  onAwake() {
    this._initDataAndUI();
    this._initTween();
    this._initListener();
  }

  onUpdate(deltaTime: number) {
    // Update the performance of the bird.
    switch (this._birdState) {
      case EnumBirdState.Alive:
        const { _frameInterval, _totalFrames } = this;
        this._cumulativeTime += deltaTime;
        if (this._cumulativeTime >= _frameInterval) {
          // Need update frameIndex.
          const addFrameCount = Math.floor(
            this._cumulativeTime / _frameInterval
          );
          this._cumulativeTime -= addFrameCount * _frameInterval;
          this._setFrameIndex(
            (this._curFrameIndex + addFrameCount) % _totalFrames
          );
        }

        // Update bird's location information.
        if (this._gameState == EnumGameState.Start) {
          // Free fall and uniform motion are superimposed to obtain the current position.

          let endY;
          const { _maxDropV, _startFlyV, _gravity } = this;
          // 通过重力，下落速度，飞行速度计算小鸟飞行中的位置
          const transform = this.entity.transform;
          const position = transform.position;
          // How much time has passed.
          const subTime = (engine.time.nowTime - this._flyStartTime) / 1000;
          // How long has it been in free fall.
          // 下落速度有一个最大值，没超过这个值时按中立加速自由下落，超过了就是一个恒定的速度
          const addToMaxUseTime = (_maxDropV - _startFlyV) / _gravity;
          if (subTime <= addToMaxUseTime) {
            // Free fall.
            endY =
              ((_startFlyV + (_startFlyV + subTime * _gravity)) * subTime) / 2 +
              this._startY;
          } else {
            // Falling at a constant speed.
            endY =
              ((_maxDropV + _startFlyV) * addToMaxUseTime) / 2 +
              _maxDropV * (subTime - addToMaxUseTime) +
              this._startY;
          }
          transform.setPosition(position.x, endY, position.z);
        }
        break;
      case EnumBirdState.Dead:
        // 死的时候重置
        this._setFrameIndex(0);
        break;
    }
  }

  onLateUpdate() {
    // After updating the position, check the collision.
    // 每次位置更新之后，触发碰撞检测
    engine.dispatch(GameEvent.checkHit, this.entity.transform.position.y);
  }

  // 初始化小鸟的贴图
  private _initDataAndUI() {
    const { entity } = this;
    const renderer = entity.getComponent(SpriteRenderer);
    renderer.sprite = this._sprite = new Sprite(engine, gameResArray[3]);
    this._setFrameIndex(0);
  }

  // 初始化小鸟的动画
  private _initTween() {
    const transform = this.entity.transform;
    const rotation = transform.rotation;
    const position = transform.position;
    // yoyo 的动画？
    this._yoyoTween = new TWEEN.Tween(position)
      .to({ y: 0.25 }, 380)
      .repeat(Infinity)
      .onUpdate((target) => {
        transform.position = target;
      })
      .yoyo(true)
      .easing(TWEEN.Easing.Sinusoidal.InOut);

    // 结束时的坠落动画
    this._dropTween = new TWEEN.Tween(rotation)
      .to({ z: -90 }, 380)
      .onUpdate((target) => {
        transform.rotation = target;
      })
      .delay(520);
  }

  // 初始化小鸟的事件响应
  private _initListener() {
    const transform = this.entity.transform;
    engine.on(GameEvent.fly, () => {
      // Record start time and location.
      this._startY = transform.position.y;
      this._flyStartTime = engine.time.nowTime;
      // Flying performance.
      this._yoyoTween.stop();
      this._dropTween.stop();
      transform.setRotation(transform.rotation.x, transform.rotation.y, 20);
      this._dropTween.start();
    });

    // Control the performance of the bird according to the change of the game state.
    // 响应游戏事件
    engine.on(GameEvent.stateChange, (gameState: EnumGameState) => {
      this._gameState = gameState;
      switch (gameState) {
        case EnumGameState.Idel:
          transform.setPosition(0, 0, 0);
          transform.rotation = new Vector3(0, 0, 0);
          this._birdState = EnumBirdState.Alive;
          this._yoyoTween.start();
          break;
        case EnumGameState.Start:
          break;
        case EnumGameState.End:
          this._birdState = EnumBirdState.Dead;
          setTimeout(() => {
            const { position, rotation } = transform;
            const birdPosY = position.y;
            if (birdPosY > groundY) {
              this._yoyoTween.stop();
              this._dropTween.stop();
              new TWEEN.Tween(rotation)
                .duration((birdPosY - groundY) * 40)
                .to({ z: -90 })
                .onUpdate((target) => {
                  transform.rotation = target;
                })
                .start();
              new TWEEN.Tween(position)
                .duration((birdPosY - groundY) * 120)
                .to({ y: groundY })
                .onUpdate((target) => {
                  transform.position = target;
                })
                .onComplete(() => {
                  engine.dispatch(GameEvent.showGui);
                })
                .start();
            } else {
              engine.dispatch(GameEvent.showGui);
            }
          }, 300);
          break;
      }
    });
  }

  private _setFrameIndex(frameIndex: number) {
    if (this._curFrameIndex !== frameIndex) {
      this._curFrameIndex = frameIndex;
      const frameInfo = this._regions[frameIndex];
      const region = this._sprite.region;
      region.set(
        frameInfo.x,
        frameInfo.y,
        this._reciprocalSliceWidth,
        this._reciprocalSliceHeight
      );
      this._sprite.region = region;
    }
  }
}

class ScriptDeathEff extends Script {
  onAwake() {
    const entity = this.entity;
    const renderer = entity.getComponent(MeshRenderer);
    const material = <UnlitMaterial>renderer.getMaterial();

    // init Tween.
    const baseColor = material.baseColor;
    const shockTween = new TWEEN.Tween(baseColor)
      .to({ a: 1 }, 80)
      .repeat(1)
      .yoyo(true)
      .delay(20);

    // 监听游戏逻辑改变
    engine.on(GameEvent.stateChange, (gameState: EnumGameState) => {
      switch (gameState) {
        case EnumGameState.End:
          shockTween.start();
          break;
      }
    });
  }
}

class ScriptScore extends Script {
  /** The sprite array used by the score（0～9）. */
  private _spriteArray: Sprite[] = [];
  /** Interval between each number. */
  private _numInv = 2;
  /** Each number in the score. */
  private _scoreEntitys: Entity[] = [];
  private _scoreRenderer: SpriteRenderer[] = [];
  private _myScore = 0;

  onAwake() {
    // Init spriteArray.
    const spriteArray = this._spriteArray;
    // Cut digital resources into ten.
    for (var i = 0; i < 10; i++) {
      // 贴图数组
      spriteArray.push(
        new Sprite(engine, gameResArray[5], new Rect(i * 0.1, 0, 0.1, 1))
      );
    }

    // 监听游戏事件：分数增加
    engine.on(GameEvent.addScore, () => {
      ++this._myScore;
      this._showScore('' + this._myScore);
    });

    // Control the performance of the score according to the change of the game state.
    // 监听游戏事件
    engine.on(GameEvent.stateChange, (gameState: EnumGameState) => {
      switch (gameState) {
        case EnumGameState.Idel:
          this.entity.isActive = false;
          break;
        case EnumGameState.Start:
          this.entity.isActive = true;
          this._myScore = 0;
          this._showScore('0');
          break;
        case EnumGameState.End:
          break;
      }
    });
  }

  private _showScore(scoreNumStr: string) {
    const scoreLen = scoreNumStr.length;
    const {
      entity,
      _numInv: inv,
      _scoreEntitys: scoreEntitys,
      _spriteArray: spriteArray,
      _scoreRenderer: scoreRenderers,
    } = this;
    var nowEntityLen = scoreEntitys.length;
    let scoreEntity: Entity;
    let scoreRenderer: SpriteRenderer;
    // If the entity is not enough, new one.
    if (scoreLen > nowEntityLen) {
      for (let i = nowEntityLen; i < scoreLen; i++) {
        scoreEntity = new Entity(engine);
        scoreRenderer = scoreEntity.addComponent(SpriteRenderer);
        scoreRenderers.push(scoreRenderer);
        scoreEntitys.push(scoreEntity);
        entity.addChild(scoreEntity);
      }
    }

    // At the moment nowEntityLen >= scoreLen.
    nowEntityLen = scoreEntitys.length;
    const startX = ((1 - scoreLen) * inv) / 2;
    for (let i = 0; i < nowEntityLen; i++) {
      scoreEntity = scoreEntitys[i];
      if (i >= scoreLen) {
        scoreEntity.isActive = false;
      } else {
        scoreEntity.isActive = true;
        scoreEntity.transform.setPosition(startX + i * inv, 0, 0);
        scoreRenderers[i].sprite = spriteArray[parseInt(scoreNumStr[i])];
      }
    }
  }
}

class GameCtrl extends Script {
  private _gameState: EnumGameState;

  onAwake() {
    engine.on(GameEvent.reStartGame, () => {
      this._setGameState(EnumGameState.Idel);
    });

    engine.on(GameEvent.gameOver, () => {
      this._setGameState(EnumGameState.End);
    });

    const boxCollider: StaticCollider = this.entity.addComponent(StaticCollider);
    const boxColliderShape = new BoxColliderShape();
    boxColliderShape.setSize(10, 10, 0.001);
    boxCollider.addShape(boxColliderShape);
  }

  onStart() {
    // Give a state at the beginning.
    this._setGameState(EnumGameState.Idel);
  }

  onUpdate() {
    // Update TWEEN.
    TWEEN.update();
    if (this.engine.inputManager.isKeyDown(Keys.Space)) {
      this._dispatchFly();
    }
  }

  onPointerDown() {
    this._dispatchFly();
  }

  private _dispatchFly() {
    switch (this._gameState) {
      case EnumGameState.Idel:
        this._setGameState(EnumGameState.Start);
        engine.dispatch(GameEvent.fly);
        break;
      case EnumGameState.Start:
        engine.dispatch(GameEvent.fly);
        break;
      default:
        break;
    }
  }

  /**
   * The status will be distributed to all objects in the game.
   * @param state - EnumGameState
   */
  private _setGameState(state: EnumGameState) {
    if (this._gameState != state) {
      this._gameState = state;
      engine.dispatch(GameEvent.stateChange, state);
    }
  }
}

class ScriptGUI extends Script {
  onAwake() {
    const { entity } = this;
    const resetBtnNode = entity.findByName("nodeRestart");

    // Add BoxCollider.
    // 为按钮增加碰撞盒，以响应点击的事件（需要物理引擎，但是用 lite 就可以了）
    const boxCollider: StaticCollider = resetBtnNode.addComponent(StaticCollider);
    const boxColliderShape = new BoxColliderShape();
    boxColliderShape.setSize(2.14, 0.75, 0.001);
    boxCollider.addShape(boxColliderShape);
    resetBtnNode.addComponent(Script).onPointerClick = () => {
      this.engine.dispatch(GameEvent.reStartGame);
    };

    // Control the performance of the GUI according to the change of the game state.
    engine.on(GameEvent.stateChange, (gameState: EnumGameState) => {
      switch (gameState) {
        case EnumGameState.Idel:
        case EnumGameState.Start:
          resetBtnNode.isActive = false;
          break;
        case EnumGameState.End:
          break;
        default:
          break;
      }
    });

    engine.on(GameEvent.showGui, () => {
      resetBtnNode.isActive = true;
    });
  }
}

export async function createOasis() {
  engine = new WebGLEngine('canvas');
  engine.canvas.resizeByClientSize();
  const scene = engine.sceneManager.activeScene;
  const rootEntity = scene.createRootEntity();

  // 2D 相机初始化
  const cameraEntity = rootEntity.createChild('camera');
  const camera = cameraEntity.addComponent(Camera);
  cameraEntity.transform.setPosition(0.3, 0, 5);
  // 2D 用正交
  camera.isOrthographic = true;
  camera.orthographicSize = engine.canvas.height / Engine._pixelsPerUnit / 2;

  // 初始化 Lite 物理引擎，按钮的点击需要这个
  engine.physicsManager.initialize(LitePhysics);

  // 加载资源
  gameResArray = (await engine.resourceManager.load([
    {
      // Background.
      url: 'https://gw.alipayobjects.com/zos/OasisHub/315000157/5244/background.png',
      type: AssetType.Texture2D,
    },
    {
      // Pipe.
      url: 'https://gw.alipayobjects.com/zos/OasisHub/315000157/5987/pipe.png',
      type: AssetType.Texture2D,
    },
    {
      // Ground.
      url: 'https://gw.alipayobjects.com/mdn/rms_7c464e/afts/img/A*Sj7OS4YJHDIAAAAAAAAAAAAAARQnAQ',
      type: AssetType.Texture2D,
    },
    {
      // Bird.
      url: 'https://gw.alipayobjects.com/zos/OasisHub/315000157/8356/bird.png',
      type: AssetType.Texture2D,
    },
    {
      // Restart.
      url: 'https://gw.alipayobjects.com/zos/OasisHub/315000157/6695/restart.png',
      type: AssetType.Texture2D,
    },
    {
      // Number.
      url: 'https://gw.alipayobjects.com/zos/OasisHub/315000157/8709/527-number.png',
      type: AssetType.Texture2D,
    },
  ])) as Texture2D[];
  // 创建背景
  const nodeBg = rootEntity.createChild('nodeBg');
  nodeBg.transform.setPosition(0.3, 0, -10);
  nodeBg.addComponent(SpriteRenderer).sprite = new Sprite(
    engine,
    gameResArray[0]
  );

  // 管道逻辑
  const nodePipe = rootEntity.createChild('nodePipe');
  nodePipe.transform.setPosition(0, 0, -3);
  nodePipe.addComponent(ScriptPipe);

  // 地面逻辑
  const nodeGround = rootEntity.createChild('nodeGround');
  nodeGround.transform.setPosition(0.3, -4.125, -2); // 设置位置
  nodeGround.transform.setRotation(90, 0, 0); // 设置旋转
  const groundRenderer = nodeGround.addComponent(MeshRenderer);
  groundRenderer.mesh = PrimitiveMesh.createPlane(engine, 7.68, 1.28);
  const groundMaterial = new UnlitMaterial(engine);
  groundRenderer.setMaterial(groundMaterial);
  groundMaterial.baseTexture = gameResArray[2];
  groundMaterial.tilingOffset.set(21, 1, 0, 0);
  nodeGround.addComponent(ScriptGround);

  // 小鸟逻辑.
  const nodeBird = rootEntity.createChild('nodeBird');
  nodeBird.transform.setPosition(-1, 1.15, 0);
  nodeBird.addComponent(SpriteRenderer).sprite = new Sprite(
    engine,
    gameResArray[3]
  );
  nodeBird.addComponent(ScriptBird);

  // 死亡特效
  const nodeDeathEff = rootEntity.createChild('nodeEff');
  nodeDeathEff.transform.setPosition(0, 0, -1);
  nodeDeathEff.transform.setRotation(90, 0, 0);
  const effRenderer = nodeDeathEff.addComponent(MeshRenderer);
  effRenderer.mesh = PrimitiveMesh.createPlane(engine, 20, 20);
  const material = new UnlitMaterial(engine); // 材质
  effRenderer.setMaterial(material);
  // Can be transparent.
  material.isTransparent = true;
  material.baseColor.set(0, 0, 0, 0);
  nodeDeathEff.addComponent(ScriptDeathEff);

  // GUI.
  const nodeGui = rootEntity.createChild('nodeGui');
  nodeGui.transform.setPosition(0.3, 0, 1);
  // 重新开始按钮
  const nodeRestart = nodeGui.createChild('nodeRestart');
  nodeRestart.addComponent(SpriteRenderer).sprite = new Sprite(
    engine,
    gameResArray[4]
  );
  // 分数显示逻辑
  const nodeScore = nodeGui.createChild('nodeScore');
  nodeScore.transform.setPosition(0, 3.2, 0);
  nodeScore.transform.setScale(0.3, 0.3, 0.3);
  nodeScore.addComponent(ScriptScore);
  // 按钮逻辑
  nodeGui.addComponent(ScriptGUI);

  // GameCtrl 负责游戏的整体控制
  // - 统一响应游戏事件
  // - 统一流转游戏状态
  // - 统一管理游戏更新的逻辑
  // - 统一响应用户操作
  rootEntity.addComponent(GameCtrl);
  engine.run();
}
